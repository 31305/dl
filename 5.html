<!doctype html>
<html>
<head>
<meta name="google-site-verification" content="k7YT-WGvMfA254iNCfCjuSTu9z99jAUBMoIikwWZM5A" />
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mentic</title>
<meta property="og:site_name" content="Mentic" />
<script type="application/ld+json">
{
"@context":"https://schema.org",
"@type":"WebSite",
"name":"Mentic",
"url":"https://mentic.web.app"
}
</script>
<link rel="icon" href="/vcm.ico"/>
</head>
<body style='image-rendering: crisp-edges;margin:0;background-color:black;overflow:hidden'>
<canvas width=0 height=0 id="canvas" style="position:absolute;display:block;width:100%;height:100%" oncontextmenu="event.preventDefault()"></canvas>
<video oncontextmenu="return false;" disablePictureInPicture crossorigin id="ccpd" disableRemotePlayback preload="metadata" style="position:fixed" playsinline hidden>
	<source src="kc.mp4"/>
	<source src="https://ik.imagekit.io/mentic/pc.mp4?updatedAt=1698197381808" />
	<source src="pc.mp4" />
</video>
<canvas hidden oncontextmenu="return false;" id="scpd" style="position:fixed" width=0 height=0 style='width:0;height:0'></canvas>
<script type='text/javascript'>
cp=document.getElementById('canvas');
ccpd=document.getElementById('ccpd');
scpd=document.getElementById('scpd');
scpv=scpd.getContext('2d')
vpv1=0;vpv2=0;
const l=new ResizeObserver((gs)=>
{
  const g=gs.find((g)=>g.target===cp);
  vpv1=g.devicePixelContentBoxSize[0].inlineSize;
  vpv2=g.devicePixelContentBoxSize[0].blockSize;
  if(0)console.log(vpv1,vpv2)
});
l.observe(cp,{box:"device-pixel-content-box"});
var Module={canvas:(function(){return cp;})()};
function sn(s)
{
	Module.ccall('sn',null,['number'],[s])
}
function nt(s)
{
	Module.ccall('nt',null,['number'],[s])
}
cc=0
ccpd.addEventListener('ended',()=>{cc=0;ccpd.hidden=true;scpd.hidden=true},false)
ccpd.addEventListener("loadedmetadata",function(){scpd.width=this.videoWidth,scpd.height=this.videoHeight;},false);
function pcl(d1,d2,v1,v2)
{
	ccpd.style.left=(d1*100/vpv1).toString()+'%'
	ccpd.style.top=(d2*100/vpv2).toString()+'%'
	ccpd.style.width=(v1*100/vpv1).toString()+'%'
	ccpd.style.height=(v2*100/vpv2).toString()+'%'
	if(0)ccpd.play()
	if(1)ccpd.hidden=false
}
function dcl(d1,d2,v1,v2)
{
	if(scpd.width==0){requestAnimationFrame(()=>{cl(d1,d2,v1,v2)});return;}
	if(scpd.width*v2>scpd.height*v1)
	{
		let pv2=v2;
		v2=v1*scpd.height/scpd.width;
		d2=d2+(pv2-v2)*0.5
	}
	else
	{
		let pv1=v1;
		v1=v2*scpd.width/scpd.height;
		d1=d1+(pv1-v1)*0.5
	}
	scpd.style.left=(d1*100/vpv1).toString()+'%'
	scpd.style.top=(d2*100/vpv2).toString()+'%'
	scpd.style.width=(v1*100/vpv1).toString()+'%'
	scpd.style.height=(v2*100/vpv2).toString()+'%'
	if(1)scpd.hidden=false
	if(0)pdr()	
}
function pdr()
{
	scpv.drawImage(ccpd,0,0)
	if(cc)ccpd.requestVideoFrameCallback(pdr)
}
pvcp=0;
dvcp=0;
tvcp=1;
function cl(d1,d2,v1,v2){if(pvcp)pcl(d1,d2,v1,v2);else if(dvcp)dcl(d1,d2,v1,v2)}
function cpdk(){if(dvcp)scpv.drawImage(ccpd,0,0)}
sk=cp.getContext('webgl');
var vpvv,kss,sgss,kcss,sgcss,ccp;
function vvk()
{
	const bv=sk.createShader(sk.VERTEX_SHADER);
	sk.shaderSource(bv,"attribute vec4 s;attribute vec2 cs;varying vec2 pcs;void main(){gl_Position=s;pcs=cs;}")
	sk.compileShader(bv)
	if(0)console.log(sk.getShaderParameter(bv,sk.COMPILE_STATUS))
	const vv=sk.createShader(sk.FRAGMENT_SHADER);
	sk.shaderSource(vv,"precision mediump float;uniform sampler2D c;varying vec2 pcs;void main(){gl_FragColor=texture2D(c,pcs);}")
	sk.compileShader(vv)
	if(0)console.log(sk.getShaderParameter(vv,sk.COMPILE_STATUS))
	vpvv=sk.createProgram()
	sk.attachShader(vpvv,bv)
	sk.attachShader(vpvv,vv)
	sk.linkProgram(vpvv)
	if(0)console.log(sk.getProgramParameter(vpvv,sk.LINK_STATUS))
	kss=sk.getAttribLocation(vpvv,"s")
	kcss=sk.getAttribLocation(vpvv,"cs")
	sgss=sk.createBuffer()
	sgcss=sk.createBuffer()
	sk.bindBuffer(sk.ARRAY_BUFFER,sgss)
	sk.bufferData(sk.ARRAY_BUFFER,new Float32Array([-1,1, 1,1, 1,-1, -1,1, -1,-1, 1,-1]),sk.STATIC_DRAW)
	sk.bindBuffer(sk.ARRAY_BUFFER,sgcss)
	sk.bufferData(sk.ARRAY_BUFFER,new Float32Array([0,0,1,0,1,1,0,0,0,1,1,1]),sk.STATIC_DRAW)
	ccp=sk.createTexture();
	sk.bindTexture(sk.TEXTURE_2D,ccp)
	sk.texParameteri(sk.TEXTURE_2D,sk.TEXTURE_WRAP_S,sk.CLAMP_TO_EDGE);
	sk.texParameteri(sk.TEXTURE_2D,sk.TEXTURE_WRAP_T,sk.CLAMP_TO_EDGE);
	sk.texParameteri(sk.TEXTURE_2D,sk.TEXTURE_MIN_FILTER,sk.NEAREST);
	sk.texParameteri(sk.TEXTURE_2D,sk.TEXTURE_MAG_FILTER,sk.NEAREST);
}
vvk()
var tkv=0,tkccp=0;
function ccvs(s1,s2,v1,v2)
{
	if(0)console.log(s1,s2,v1,v2)
	if(0)if(tkccp==0)tkccp=sk.getParameter(sk.TEXTURE_BINDING_2D)
	sk.bindTexture(sk.TEXTURE_2D,ccp)
	sk.texImage2D(sk.TEXTURE_2D,0,sk.RGBA,sk.RGBA,sk.UNSIGNED_BYTE,ccpd);
	if(1)sk.viewport(s1,cp.height-s2-v2,v1,v2);
	if(tkv==0)tkv=sk.getParameter(sk.CURRENT_PROGRAM)
	sk.useProgram(vpvv)
	sk.enableVertexAttribArray(kss)
	sk.bindBuffer(sk.ARRAY_BUFFER,sgss)
	sk.vertexAttribPointer(kss,2,sk.FLOAT,false,0,0)
	sk.enableVertexAttribArray(kcss)
	sk.bindBuffer(sk.ARRAY_BUFFER,sgcss)
	sk.vertexAttribPointer(kcss,2,sk.FLOAT,false,0,0)
	if(1)sk.drawArrays(sk.TRIANGLES,0,6)
	if(1)sk.viewport(0,0,cp.width,cp.height)
	sk.useProgram(tkv)
	if(1)sk.bindTexture(sk.TEXTURE_2D,tkccp)
	return 1;
}
</script>
<script src="sv.js"></script>
</body>
</html>
